I"º<p>The traveling salesman problem (TSP) asks the following question: ‚ÄúGiven a list of n cities, among which an origin city, and the distances between each pair of cities, what is the shortest possible route that visits each city exactly once and returns to the origin city?‚Äù This is an important NP-hard combinatorial optimization problem, particularly in the fields of operations research and theoretical computer science. The problem was first formulated in 1930 and is one of the most intensively studied problems in discrete optimization. <br />
In the <a href="https://paul-cayet.github.io/2022/05/19/sa_article1.html">previous post</a>, we used heuristics to solve the TSP problem. In this post we will improve our solutions using metaheuristics.</p>

<p><img src="\img\posts\combinatorial2\tsp_img.png" alt="tsp_img" width="100%" /></p>

<h2 id="1-metaheuristics">1. Metaheuristics</h2>

<p>As we saw in the previous post, computing optimal solutions is intractable for many optimization problems of industrial and scientific importance. In practice, we must find alternative methods such as heuristic or metaheuristic algorithms and be satisfied with ‚Äúgood‚Äù resulting solutions. <br />
Metaheuristic search methods can be defined as ‚Äúupper level‚Äù general methodologies used to solve specific optimization problems. There are two common design questions related to all iterative metaheuristics: the representation of solutions handled by algorithms and the definition of the objective function that will guide the search.</p>

<h3 id="representation">Representation</h3>

<p>When designing a metaheuristics, we need to think of a way to encode a solution. Although many representations may exists for a specific problem, a representation must follow common characteristics :</p>
<ul>
  <li><strong>Completeness:</strong> All solutions associated with the problem must be represented.</li>
  <li><strong>Connexity:</strong> A search path must exist between any two solutions of the search space, such that any solution can be attained.</li>
  <li><strong>Efficiency:</strong> The representation must be easy to manipulate by the search operators. The time and space complexities of the operators dealing with the representation must be reduced.</li>
</ul>

<p>For the TSP problem, we will use a simple list encoding, with the i-th element of the list being the i-th city to be visited, in order.</p>

<h3 id="cost-function">Cost function</h3>

<p>The objective function or cost function formulates the goal to achieve. It associates with each solution of the search space a real value that describes the quality or the fitness of the solution. It is an important element in designing a metaheuristic. It will
guide the search toward ‚Äúgood‚Äù solutions of the search space. If the objective function is improperly defined, it can lead to nonacceptable solutions whatever metaheuristic is used.</p>

<p>For instance, we will use the following objective function :</p>

<p><img src="\img\posts\combinatorial2\eq_fun.png" alt="eq_fun" width="50%" /></p>

<p>where œÄ represents a permutation encoding a tour and n the number of cities. <br />
<br />
There exist two families of metaheuritics algorithms : population-based, where a family of solution is generated and modified during the optimization process, and trajectory-based, were the initial solution is modified. Here we will use the Simulated Annealing algorithm, which is a simple trajectory-based algorithm.<br />
Metaheuristics work in a similar way :</p>
<ul>
  <li>At first, an initial solution (or family of solutions) is generated</li>
  <li>During the optimization, the algorithm ‚Äúnavigates‚Äù in the search space by modifying the solution with operators, while trying to avoid local optima.</li>
</ul>

<p>At the end of the optimization process, the best solution is returned.</p>

<h3 id="helper-functions">Helper functions</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">csv</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="n">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="n">plt</span>
<span class="n">plt</span><span class="p">.</span><span class="n">style</span><span class="p">.</span><span class="n">use</span><span class="p">(</span><span class="s">'seaborn'</span><span class="p">)</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">random</span>

<span class="k">def</span> <span class="nf">loadFixedInstance</span><span class="p">(</span><span class="n">fileName</span><span class="p">):</span>
    <span class="n">folderName</span> <span class="o">=</span> <span class="s">"Instances/"</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="s">".csv"</span> <span class="ow">in</span> <span class="n">fileName</span><span class="p">):</span>
        <span class="n">fileName</span> <span class="o">+=</span> <span class="s">".csv"</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">folderName</span> <span class="ow">in</span> <span class="n">fileName</span><span class="p">):</span>
        <span class="n">fileName</span> <span class="o">=</span> <span class="n">folderName</span> <span class="o">+</span> <span class="n">fileName</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">fileName</span><span class="p">)</span> <span class="k">as</span> <span class="nb">file</span><span class="p">:</span>
        <span class="n">lines</span> <span class="o">=</span> <span class="n">csv</span><span class="p">.</span><span class="n">reader</span><span class="p">(</span><span class="nb">file</span><span class="p">)</span>
        <span class="n">instance</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">lines</span><span class="p">:</span>
            <span class="n">instance</span><span class="p">.</span><span class="n">append</span><span class="p">((</span><span class="nb">int</span><span class="p">(</span><span class="n">line</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="nb">int</span><span class="p">(</span><span class="n">line</span><span class="p">[</span><span class="mi">1</span><span class="p">])))</span>
    <span class="k">return</span> <span class="n">instance</span>

<span class="k">def</span> <span class="nf">computeDistanceBetweenCities</span><span class="p">(</span><span class="n">city1</span><span class="p">,</span> <span class="n">city2</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">np</span><span class="p">.</span><span class="n">linalg</span><span class="p">.</span><span class="n">norm</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="n">array</span><span class="p">(</span><span class="n">city2</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="p">.</span><span class="n">array</span><span class="p">(</span><span class="n">city1</span><span class="p">),</span> <span class="nb">ord</span> <span class="o">=</span> <span class="mi">2</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">combinatorialConverter</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">elt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">elt</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)),</span><span class="n">x</span><span class="p">),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">reverse</span><span class="o">=</span><span class="bp">False</span><span class="p">)]</span>
    
<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="n">L</span> <span class="o">=</span> <span class="n">combinatorialConverter</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">routeDistance</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">routeDistance</span> <span class="o">+=</span> <span class="n">computeDistanceBetweenCities</span><span class="p">(</span><span class="n">instance</span><span class="p">[</span><span class="n">L</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]],</span><span class="n">instance</span><span class="p">[</span><span class="n">L</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span> 
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">routeDistance</span> <span class="o">+=</span> <span class="n">computeDistanceBetweenCities</span><span class="p">(</span><span class="n">instance</span><span class="p">[</span><span class="n">L</span><span class="p">[</span><span class="n">i</span><span class="p">]],</span><span class="n">instance</span><span class="p">[</span><span class="n">L</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]])</span> 
    <span class="k">return</span> <span class="n">routeDistance</span>

<span class="k">def</span> <span class="nf">plotRoute</span><span class="p">(</span><span class="n">route</span><span class="p">):</span>
    <span class="n">xs</span> <span class="o">=</span> <span class="p">[</span><span class="n">instance</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">route</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">instance</span><span class="p">[</span><span class="n">route</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="mi">0</span><span class="p">]]</span>
    <span class="n">ys</span> <span class="o">=</span> <span class="p">[</span><span class="n">instance</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">route</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">instance</span><span class="p">[</span><span class="n">route</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="mi">1</span><span class="p">]]</span>
    <span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span> <span class="n">ys</span><span class="p">,</span> <span class="s">'o-'</span><span class="p">)</span>
    <span class="n">plt</span><span class="p">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s">'x'</span><span class="p">)</span>
    <span class="n">plt</span><span class="p">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s">'y'</span><span class="p">)</span>
    <span class="n">plt</span><span class="p">.</span><span class="n">show</span><span class="p">()</span>
    
<span class="c1">#------Optimization functions---------#
</span>
<span class="k">def</span> <span class="nf">distMatrix</span><span class="p">(</span><span class="n">cities</span><span class="p">):</span>
    <span class="n">M</span><span class="o">=</span><span class="p">[]</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">cities</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="n">L</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="n">L</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">computeDistanceBetweenCities</span><span class="p">(</span><span class="n">cities</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">cities</span><span class="p">[</span><span class="n">j</span><span class="p">]))</span>
        <span class="n">M</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">L</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">M</span>

<span class="k">def</span> <span class="nf">sample_random</span><span class="p">(</span><span class="n">end</span><span class="p">):</span>
    <span class="s">"""sample 2 different numbers"""</span>
    <span class="n">i</span> <span class="o">=</span> <span class="n">random</span><span class="p">.</span><span class="n">randrange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">end</span><span class="p">)</span>
    <span class="n">j</span> <span class="o">=</span> <span class="n">random</span><span class="p">.</span><span class="n">randrange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">end</span><span class="p">)</span>
    <span class="k">while</span> <span class="n">i</span><span class="o">==</span><span class="n">j</span><span class="p">:</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">random</span><span class="p">.</span><span class="n">randrange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">end</span><span class="p">)</span>
        <span class="n">j</span> <span class="o">=</span> <span class="n">random</span><span class="p">.</span><span class="n">randrange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">end</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span>
</code></pre></div></div>

<p>We use the same code from the last post :</p>
<ul>
  <li>a function to build a distance matrix between the cities</li>
  <li>an evaluation function to check solution quality</li>
  <li>a function to plot the results</li>
</ul>

<h2 id="search-operators">Search operators</h2>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">twoOpt</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">):</span>
    <span class="s">"""perform permutation
    x : current solution
    i&lt;j is necessary"""</span>
    <span class="k">if</span> <span class="n">i</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">x</span><span class="p">[:</span><span class="n">i</span><span class="p">]</span><span class="o">+</span><span class="n">x</span><span class="p">[</span><span class="n">j</span><span class="p">::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">x</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span>
    <span class="k">return</span> <span class="n">x</span><span class="p">[:</span><span class="n">i</span><span class="p">]</span><span class="o">+</span><span class="n">x</span><span class="p">[</span><span class="n">j</span><span class="p">:</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">x</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span>

<span class="k">def</span> <span class="nf">randomPermutation</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="n">matDist</span><span class="p">):</span>
    <span class="s">"""Find neighbour using 2-opt exchange operator and return its score
    x : current solution
    n : len of x"""</span>
    <span class="n">i</span><span class="p">,</span><span class="n">j</span> <span class="o">=</span> <span class="n">sample_random</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">i</span><span class="o">&gt;</span><span class="n">j</span><span class="p">:</span>
        <span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="o">=</span><span class="n">j</span><span class="p">,</span><span class="n">i</span>
    <span class="n">oldScore</span> <span class="o">=</span> <span class="n">dScore</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">matDist</span><span class="p">)</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">twoOpt</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)</span>
    <span class="n">deltaScore</span> <span class="o">=</span> <span class="n">modifiedObjFunc</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">oldScore</span><span class="p">,</span><span class="n">matDist</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">x</span><span class="p">,</span> <span class="n">deltaScore</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span>
</code></pre></div></div>

<p>How to navigate trough the search space ? We use operators that modify the solution by returning a ‚Äúneighbour‚Äù solution. We must then define what is a neighbour solution for the TSP solution. <br />
A straightforward approach consists in choosing two cities and changing their position in the list. Is is called the swap operator. The problem however with this operator is that we may observe a large variation generated depending on the cities chosen (called weak locality). <br />
A better approach is the Œª-opt operator, and especially the 2-opt operator which consists in swapping edges instead of cities. This operator ensures a strong locality.</p>

<p><img src="\img\posts\combinatorial2\tsp_operators.png" alt="tsp_operators" width="100%" /></p>

<h2 id="objective-function">Objective function</h2>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">fcomb</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">distMat</span><span class="p">):</span>
    <span class="n">routeDistance</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">routeDistance</span> <span class="o">+=</span> <span class="n">distMat</span><span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]][</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">routeDistance</span> <span class="o">+=</span> <span class="n">distMat</span><span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]][</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]]</span> 
    <span class="k">return</span> <span class="n">routeDistance</span>

<span class="k">def</span> <span class="nf">dScore</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">matDist</span><span class="p">):</span>
    <span class="n">s</span><span class="o">=</span><span class="mi">0</span>
    <span class="k">if</span> <span class="n">i</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
        <span class="n">s</span><span class="o">+=</span><span class="n">matDist</span><span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1">#i=0, need to update distance between x[0] and x[-1]
</span>        <span class="n">s</span><span class="o">+=</span><span class="n">matDist</span><span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]][</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
    <span class="k">if</span> <span class="n">j</span><span class="o">&lt;</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
        <span class="n">s</span><span class="o">+=</span><span class="n">matDist</span><span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="n">j</span><span class="p">],</span><span class="n">x</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1">#j=n-1, need to update distance between x[0] and x[-1]
</span>        <span class="n">s</span><span class="o">+=</span><span class="n">matDist</span><span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]][</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
    <span class="k">return</span> <span class="n">s</span>

<span class="k">def</span> <span class="nf">modifiedObjFunc</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">oldScore</span><span class="p">,</span><span class="n">matDist</span><span class="p">):</span>
    <span class="s">"""compute the delta of score in an optimized way
    OldScore : sum of the distance between x[i-1]&amp;x[i] and between x[j]&amp;x[j+1]"""</span>
    <span class="k">return</span> <span class="n">dScore</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">matDist</span><span class="p">)</span><span class="o">-</span><span class="n">oldScore</span>
</code></pre></div></div>

<p>We can use the simple function formulation as sum of the length of the cycle. However, if we think about it, at each iteration, only a part of the solution is modified, thus we could only compute the difference in the cost induced by the search operator. That is exactly what the function <em>dScore</em> is doing.</p>

<h2 id="simulated-annealing">Simulated Annealing</h2>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">SA</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">iTemp</span><span class="p">,</span> <span class="n">fTemp</span><span class="p">,</span> <span class="n">nPerm</span><span class="p">,</span> <span class="n">cRate</span><span class="p">,</span> <span class="n">distMat</span><span class="p">):</span>
    <span class="s">"""solve tsp instance using optimized simulated annealing"""</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x0</span><span class="p">)</span>
    <span class="n">T</span> <span class="o">=</span> <span class="n">iTemp</span>
    <span class="n">niter</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">SCORES</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">x0</span><span class="p">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">score</span> <span class="o">=</span> <span class="n">fcomb</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">distMat</span><span class="p">)</span>
    <span class="n">best_score</span><span class="o">=</span><span class="n">score</span>
    <span class="n">bestx</span> <span class="o">=</span> <span class="n">x0</span><span class="p">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">ptime</span> <span class="o">=</span> <span class="n">time</span><span class="p">.</span><span class="n">time</span><span class="p">()</span>
    <span class="n">titer</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">log</span><span class="p">(</span><span class="n">fTemp</span><span class="o">/</span><span class="n">iTemp</span><span class="p">)</span><span class="o">/</span><span class="n">np</span><span class="p">.</span><span class="n">log</span><span class="p">(</span><span class="n">cRate</span><span class="p">)</span>
    
    <span class="k">while</span> <span class="n">T</span><span class="o">&gt;</span><span class="n">fTemp</span><span class="p">:</span>
<span class="c1">#         if niter%20000==0:
#             print(f'Time elapsed : {round(time.time()-ptime,1)}s, {round(100*(niter/nPerm)/titer,1)} %')
</span>        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nPerm</span><span class="p">):</span>
            <span class="n">x</span><span class="p">,</span> <span class="n">deltaScore</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">randomPermutation</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="n">distMat</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">deltaScore</span><span class="o">&lt;</span><span class="mi">0</span> <span class="ow">or</span> <span class="n">random</span><span class="p">.</span><span class="n">random</span><span class="p">()</span><span class="o">&lt;</span><span class="n">np</span><span class="p">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">deltaScore</span><span class="o">/</span><span class="n">T</span><span class="p">):</span>
                <span class="n">score</span><span class="o">+=</span><span class="n">deltaScore</span> <span class="c1">#we need the true score for best solution calculation
</span>                <span class="k">if</span> <span class="n">score</span><span class="o">&lt;</span><span class="n">best_score</span><span class="p">:</span>
                    <span class="n">bestx</span> <span class="o">=</span> <span class="n">x</span><span class="p">.</span><span class="n">copy</span><span class="p">()</span>
                    <span class="n">best_score</span> <span class="o">=</span> <span class="n">score</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1">#reverse operator
</span>                <span class="n">x</span> <span class="o">=</span> <span class="n">twoOpt</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)</span>
            <span class="n">niter</span><span class="o">+=</span><span class="mi">1</span>
        <span class="n">SCORES</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">score</span><span class="p">)</span>
        <span class="n">T</span><span class="o">*=</span><span class="n">cRate</span>
    <span class="k">return</span> <span class="n">bestx</span><span class="p">,</span> <span class="n">best_score</span><span class="p">,</span> <span class="n">SCORES</span>
</code></pre></div></div>

<p>Finally, we can implement the optimization procedure. In the early 1980s three IBM researchers, Kirkpatrick et al., introduced the concepts of annealing in combinatorial optimization. These concepts are based on a strong analogy with the physical annealing of materials. This process involves bringing a solid to a low energy state after raising its temperature. In the context of the optimization algorithm, the function to be minimized represents the energy of the solid.
<br />
The procedure goes as follows :</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Initialization</span> <span class="p">(</span><span class="n">i</span> <span class="p">:</span><span class="o">=</span> <span class="n">istart</span><span class="p">,</span> <span class="n">k</span> <span class="p">:</span><span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ck</span> <span class="o">=</span> <span class="n">c0</span><span class="p">,</span> <span class="n">Lk</span> <span class="p">:</span><span class="o">=</span> <span class="n">L0</span><span class="p">)</span>
<span class="k">while</span> <span class="ow">not</span><span class="p">(</span><span class="n">ck</span><span class="err">‚âÉ</span><span class="mi">0</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">l</span> <span class="o">=</span> <span class="mi">0</span> <span class="n">to</span> <span class="n">Lk</span> <span class="n">do</span><span class="p">:</span>
        <span class="n">Generate</span> <span class="n">a</span> <span class="n">solution</span> <span class="n">j</span> <span class="k">from</span> <span class="n">the</span> <span class="n">neighborhood</span> <span class="n">Si</span> <span class="n">of</span> <span class="n">the</span> <span class="n">current</span> <span class="n">solution</span> <span class="n">i</span>
        <span class="n">If</span> <span class="n">f</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">f</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="n">then</span> <span class="n">i</span> <span class="p">:</span><span class="o">=</span> <span class="n">j</span> <span class="p">(</span><span class="n">j</span> <span class="n">becomes</span> <span class="n">the</span> <span class="n">current</span> <span class="n">solution</span><span class="p">)</span>
        <span class="n">Else</span><span class="p">,</span> <span class="n">j</span> <span class="n">becomes</span> <span class="n">the</span> <span class="n">current</span> <span class="n">solution</span> <span class="k">with</span> <span class="n">probability</span> <span class="n">exp</span><span class="p">[(</span><span class="n">f</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="err">‚àí</span><span class="n">f</span><span class="p">(</span><span class="n">j</span><span class="p">))</span><span class="o">/</span><span class="n">Tk</span><span class="p">]</span>
    <span class="n">k</span> <span class="p">:</span><span class="o">=</span> <span class="n">k</span><span class="o">+</span><span class="mi">1</span>
    <span class="n">Compute</span><span class="p">(</span><span class="n">Lk</span><span class="p">,</span> <span class="n">ck</span><span class="p">)</span>
</code></pre></div></div>

<p><img src="\img\posts\combinatorial2\Hill_Climbing_with_Simulated_Annealing.png" alt="Hill_Climbing_with_Simulated_Annealing" width="100%" /></p>

<p>When the temperature is high, the algorithm performs an exploration phase to find promising parts of the solution space (the probability of accepting a non-improving solution is around 1).<br />
When the temperature is low, the algorithm intensifies its search, and non-improving solutions are less likely to be accepted. <br />
At each temperature stage, we perform a fixed number of iteration to sufficiently navigate the search space, and we decrease the temperature with a geometric cooling scheme.</p>

<h2 id="how-to-choose-the-initial-temperature-">How to choose the initial temperature ?</h2>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">ITAcceptance</span><span class="p">(</span><span class="n">solution</span><span class="p">,</span><span class="n">acceptance_rate</span><span class="p">,</span><span class="n">n_samples</span><span class="p">,</span><span class="n">matDist</span><span class="p">):</span>
    <span class="s">"""compute initial temperature such that a certain acceptance rate is achieved
    T-&gt;0 if R-&gt;0.5 and T-&gt;oo if R-&gt;1"""</span>
    <span class="n">m1</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">m2</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">DF</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">solution</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_samples</span><span class="p">):</span>
        <span class="n">solution</span><span class="p">,</span> <span class="n">deltaScore</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">randomPermutation</span><span class="p">(</span><span class="n">solution</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="n">matDist</span><span class="p">)</span>
        <span class="n">solution</span> <span class="o">=</span> <span class="n">twoOpt</span><span class="p">(</span><span class="n">solution</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">deltaScore</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">:</span>
            <span class="n">DF</span><span class="o">-=</span><span class="n">deltaScore</span>
            <span class="n">m1</span><span class="o">+=</span><span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">m2</span><span class="o">+=</span><span class="mi">1</span>
    <span class="n">mDF</span> <span class="o">=</span> <span class="n">DF</span><span class="o">/</span><span class="n">m1</span>
    <span class="k">return</span> <span class="n">mDF</span><span class="o">/</span><span class="n">np</span><span class="p">.</span><span class="n">log</span><span class="p">(</span><span class="n">m2</span><span class="o">/</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">m2</span><span class="o">*</span><span class="n">acceptance_rate</span><span class="o">-</span><span class="n">m1</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">acceptance_rate</span><span class="p">))))</span>
</code></pre></div></div>

<p>It can be difficult to choose an initial temperature, as it depends on the type of problem and the objective function. Thus, we choose the initial temperature such that X% of the initial neighbours are accepted. In fact, we simulate the algorithm a certain number of time, and compute the initial temperature needed to meet the ‚Äúacceptance requirements‚Äù. For the experiments, the ending temperature is set as T0/1000.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">instance</span> <span class="o">=</span> <span class="n">loadFixedInstance</span><span class="p">(</span><span class="s">"TSPInstance150.csv"</span><span class="p">)</span>
<span class="n">matDist</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">array</span><span class="p">(</span><span class="n">distMatrix</span><span class="p">(</span><span class="n">instance</span><span class="p">))</span>

<span class="n">initx</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">instance</span><span class="p">)))</span>
<span class="n">T0</span> <span class="o">=</span> <span class="n">ITAcceptance</span><span class="p">(</span><span class="n">initx</span><span class="p">,</span><span class="mf">0.8</span><span class="p">,</span><span class="mi">10000</span><span class="p">,</span><span class="n">matDist</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">'T0 : </span><span class="si">{</span><span class="nb">round</span><span class="p">(</span><span class="n">T0</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span><span class="si">}</span><span class="s">'</span><span class="p">)</span>
<span class="n">ptime</span> <span class="o">=</span> <span class="n">time</span><span class="p">.</span><span class="n">time</span><span class="p">()</span>
<span class="n">bestx</span><span class="p">,</span> <span class="n">best_score</span><span class="p">,</span> <span class="n">SCORES</span> <span class="o">=</span> <span class="n">SA</span><span class="p">(</span><span class="n">initx</span><span class="p">,</span> <span class="n">T0</span><span class="p">,</span> <span class="n">T0</span><span class="o">/</span><span class="mi">1000</span><span class="p">,</span> <span class="mi">500</span><span class="p">,</span> <span class="mf">0.995</span><span class="p">,</span> <span class="n">matDist</span><span class="p">)</span>

<span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">'Optimization done in </span><span class="si">{</span><span class="nb">round</span><span class="p">(</span><span class="n">time</span><span class="p">.</span><span class="n">time</span><span class="p">()</span><span class="o">-</span><span class="n">ptime</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span><span class="si">}</span><span class="s"> s, the best score was : </span><span class="si">{</span><span class="nb">round</span><span class="p">(</span><span class="n">best_score</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span><span class="si">}</span><span class="s">'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">SCORES</span><span class="p">))),</span><span class="n">SCORES</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">show</span><span class="p">()</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>T0 : 120.7
Optimization done in 25.4 s, the best score was : 1908.2
</code></pre></div></div>

<p><img src="\img\posts\combinatorial2\output_25_1.png" alt="output_25_1" width="100%" /></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">plotRoute</span><span class="p">(</span><span class="n">bestx</span><span class="p">)</span>
</code></pre></div></div>

<p><img src="\img\posts\combinatorial2\output_26_0.png" alt="output_26_0" width="100%" /></p>

<p>In only 25 seconds we were able to find a pretty good solution with no overlapping trajectories. We can tweak the parameters to gain even more speed (as we can see the optimization was almost finished at 800 temperature iterations). <br />
Let‚Äôs try the instance with 400 cities !</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">instance</span> <span class="o">=</span> <span class="n">loadFixedInstance</span><span class="p">(</span><span class="s">"TSPInstance400.csv"</span><span class="p">)</span>
<span class="n">matDist</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">array</span><span class="p">(</span><span class="n">distMatrix</span><span class="p">(</span><span class="n">instance</span><span class="p">))</span>

<span class="n">initx</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">instance</span><span class="p">)))</span>
<span class="n">T0</span> <span class="o">=</span> <span class="n">ITAcceptance</span><span class="p">(</span><span class="n">initx</span><span class="p">,</span><span class="mf">0.8</span><span class="p">,</span><span class="mi">10000</span><span class="p">,</span><span class="n">matDist</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">'T0 : </span><span class="si">{</span><span class="nb">round</span><span class="p">(</span><span class="n">T0</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span><span class="si">}</span><span class="s">'</span><span class="p">)</span>
<span class="n">ptime</span> <span class="o">=</span> <span class="n">time</span><span class="p">.</span><span class="n">time</span><span class="p">()</span>
<span class="n">bestx</span><span class="p">,</span> <span class="n">best_score</span><span class="p">,</span> <span class="n">SCORES</span> <span class="o">=</span> <span class="n">SA</span><span class="p">(</span><span class="n">initx</span><span class="p">,</span> <span class="n">T0</span><span class="p">,</span> <span class="n">T0</span><span class="o">/</span><span class="mi">1000</span><span class="p">,</span> <span class="mi">500</span><span class="p">,</span> <span class="mf">0.996</span><span class="p">,</span> <span class="n">matDist</span><span class="p">)</span>

<span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">'Optimization done in </span><span class="si">{</span><span class="nb">round</span><span class="p">(</span><span class="n">time</span><span class="p">.</span><span class="n">time</span><span class="p">()</span><span class="o">-</span><span class="n">ptime</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span><span class="si">}</span><span class="s"> s, the best score was : </span><span class="si">{</span><span class="nb">round</span><span class="p">(</span><span class="n">best_score</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span><span class="si">}</span><span class="s">'</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">plot</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">SCORES</span><span class="p">))),</span><span class="n">SCORES</span><span class="p">)</span>
<span class="n">plt</span><span class="p">.</span><span class="n">show</span><span class="p">()</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>T0 : 126.6
Optimization done in 28.7 s, the best score was : 3184.2
</code></pre></div></div>

<p><img src="\img\posts\combinatorial2\output_28_1.png" alt="output_28_1" width="100%" /></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">plotRoute</span><span class="p">(</span><span class="n">bestx</span><span class="p">)</span>
</code></pre></div></div>

<p><img src="\img\posts\combinatorial2\output_29_0.png" alt="output_29_0" width="100%" /></p>

<p>We did it ! The instance was solved in less than 30 seconds. This experiment shows that, using the right search operators and an optimized objective function, the simulated annealing algorithm is a great optimization algorithm.</p>

<h2 id="and-then-">And then ?</h2>

<p>In this tutorial we saw that using metaheuristics enable us to solve NP-hard cominbatorial problems in a reasonable time. Here we used the Simulated Annealing algorithm but many, many more algorithms do exist. If you are interested in these other algorithms, I recommand the Handbook of Metaheuristics by Springer (third version as of may 2022, can be found online) which contains a complete overview of classical metaheuristics algorithms.</p>

<p>Source :</p>
<ul>
  <li>Talbi (2009). Metaheuristics - From Design To Implementation. Wiley.</li>
  <li>Gendreau, Potvin (2019). Handbook of Metaheuristics (3rd edition). Springer.</li>
</ul>

<p>Credits : Photo by CHUTTERSNAP on <a href="https://https://unsplash.com/">Unsplash</a></p>
:ET